é›»å­ä½å…ƒä¸²æ©Ÿç‡è¨ˆç®—ä»‹ç´¹
# é›»å­ä½å…ƒä¸²æ©Ÿç‡è¨ˆç®—ï¼šé™åˆ¶é€£çºŒ 1 çš„é•·åº¦

æœ¬å°ˆæ¡ˆç‚ºä¸€å€‹éè¿´èˆ‡å‹•æ…‹è¦åŠƒçµåˆçš„ C++ å¯¦ä½œï¼Œç›®çš„æ˜¯è¨ˆç®—çµ¦å®šä½å…ƒæ©Ÿç‡åºåˆ—ä¸­ï¼Œä¸åŒ…å«ã€Œé€£çºŒ k å€‹ 1ã€çš„æƒ…æ³ä¸‹ï¼Œæ‰€æœ‰å¯èƒ½çµ„åˆçš„ç¸½æ©Ÿç‡ã€‚

## ğŸ”§ å°ˆæ¡ˆå…§å®¹

- `é›»å­ä½å…ƒä¸²æ©Ÿç‡è¨ˆç®—.cpp`ï¼šæ ¸å¿ƒæ¼”ç®—æ³•ï¼Œä½¿ç”¨éè¿´ + è¨˜æ†¶åŒ–è§£æ³•ï¼ˆMemoizationï¼‰å¯¦ä½œ `calculateProbabilityDP` å‡½å¼ã€‚
- `é›»å­ä½å…ƒä¸²æ©Ÿç‡è¨ˆç®—.pdf`ï¼šä½œæ¥­é¡Œç›®èªªæ˜èˆ‡ç›¸é—œèƒŒæ™¯å…§å®¹ã€‚

## ğŸ“Œ åŠŸèƒ½èªªæ˜

- è¼¸å…¥å­—ä¸²é•·åº¦ `n` èˆ‡é€£çºŒ 1 çš„é™åˆ¶ `k`
- è¼¸å…¥æ¯å€‹ä½å…ƒç‚º 1 çš„æ©Ÿç‡
- è¨ˆç®—ä¸åŒ…å«é€£çºŒ k å€‹ 1 çš„æ‰€æœ‰æ’åˆ—ç¸½æ©Ÿç‡

## ğŸ’¡ ä½¿ç”¨æŠ€è¡“

- C++ èªè¨€
- `unordered_map` è¨˜æ†¶åŒ–éè¿´
- è‡ªå®šç¾© `State` çµæ§‹èˆ‡ Hash å‡½å¼
- ä½¿ç”¨ `iomanip` æ§åˆ¶è¼¸å‡ºæ ¼å¼

ç¨‹å¼ç¢¼:


#include <iostream>
#include <vector>
#include <unordered_map>
#include <iomanip>

using namespace std;

// ä½¿ç”¨çµæ§‹é«”ä¾†ç°¡åŒ–ç‹€æ…‹è¡¨ç¤º
struct State {
    int pos;
    int consecutiveOnes;

    bool operator==(const State& other) const {
        return pos == other.pos && consecutiveOnes == other.consecutiveOnes;
    }
};
struct StateHash {
    size_t operator()(const State& s) const {
        return hash<int>()(s.pos) ^ hash<int>()(s.consecutiveOnes);
    }
};

// è¨˜æ†¶åŒ–çµæ§‹ä¾†å„²å­˜å­å•é¡Œçµæœ
unordered_map<State, double, StateHash> memo;

// éè¿´å‡½å¼ï¼Œè¨ˆç®—ä¸åŒ…å«é€£çºŒ k å€‹ 1 çš„æ©Ÿç‡
double calculateProbabilityDP(int pos, int consecutiveOnes, int n, int k, const vector<double>& probabilities) {
    if (consecutiveOnes >= k) return 0.0;  // å·²é”åˆ° k å€‹é€£çºŒçš„ 1ï¼Œç›´æ¥è¿”å› 0
    if (pos == n) return 1.0;  // èµ°å®Œæ‰€æœ‰ç¯€é»ä¸”æœªé”åˆ° k å€‹é€£çºŒçš„ 1

    // å»ºç«‹ç‹€æ…‹
    State currentState = {pos, consecutiveOnes};
    if (memo.find(currentState) != memo.end()) return memo[currentState];

    // é¸æ“‡åŒ…æ‹¬æˆ–ä¸åŒ…æ‹¬ç•¶å‰ä½å…ƒç‚º 1 çš„æƒ…æ³
    double includeOne = probabilities[pos] * calculateProbabilityDP(pos + 1, consecutiveOnes + 1, n, k, probabilities);
    double excludeOne = (1 - probabilities[pos]) * calculateProbabilityDP(pos + 1, 0, n, k, probabilities);

    memo[currentState] = includeOne + excludeOne;
    return memo[currentState];
}

double calculateProbability(int n, int k, const vector<double>& probabilities) {
    memo.clear();
    return calculateProbabilityDP(0, 0, n, k, probabilities);
}

int main() {
    int n, k;
    cout << "è¼¸å…¥å­—ä¸²çš„é•·åº¦ n å’Œé€£çºŒ 1 çš„é™åˆ¶ kï¼š";
    while (cin >> n >> k) {
        if (n == 0) break;

        vector<double> probabilities(n);
        cout << "è¼¸å…¥æ¯å€‹ä½å…ƒå‡ºç¾ 1 çš„æ©Ÿç‡ï¼ˆå…± " << n << " å€‹ï¼‰ï¼š\n";
        for (int i = 0; i < n; ++i) {
            cout << "ç¬¬ " << i + 1 << " ä½çš„æ©Ÿç‡ï¼š";
            cin >> probabilities[i];
        }

        double result = calculateProbability(n, k, probabilities);
        cout << "ä¸åŒ…å« " << k << " å€‹æˆ–ä»¥ä¸Šé€£çºŒ 1 çš„æ¦‚ç‡ç‚ºï¼š" << fixed << setprecision(5) << result << endl;
        cout << "\nè¼¸å…¥å­—ä¸²çš„é•·åº¦ n å’Œé€£çºŒ 1 çš„é™åˆ¶ kï¼ˆæˆ–è¼¸å…¥ 0 çµæŸç¨‹å¼ï¼‰ï¼š";
    }

    cout << "ç¨‹å¼å·²çµæŸã€‚\n";
    return 0;
}
